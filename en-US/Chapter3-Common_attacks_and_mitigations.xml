<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
<!ENTITY % BOOK_ENTITIES SYSTEM "Secure_Ruby_Development_Guide.ent">
%BOOK_ENTITIES;
]>
<section>
  <title>Common attacks and mitigations</title>
  <section>
    <title>Cross site scripting (XSS)</title>
    <para></para>
  </section>

  <section>
    <title>Cross site request forgery (CSRF)</title>
    <para>
      By default, browsers include user's authentication tokens (such as cookies, HTTP basic authentication credentials etc.) with every request to the web application. This allows client to authenticate once and each following request to the web application will be authenticated without prompting the user for credentials. However, this gives client's browser ability to make authenticated requests on behalf of the user without user's explicit consent.
    </para>

    <para>
      This behaviour can be misused by the attacker to confuse client's browser into issuing an authenticated request. For example, if attacker's website contains this simple script tag
    </para>

    <programlisting>
&lt;script src="http://victimbank.com/transfermoney?to=attacker&amp;amount=1000"/&gt;
    </programlisting>

    <para>
      browser will issue a HTTP GET request to victimbank.com with parameters supplied by the attacker. The browser does not know anything about the resource that is being requested by the attacker's site - whether it is malicious of harmless - and it requests the script from the specified URL. If the user is authenticated at that moment, browser will also include his credentials, so the request would look like this:
    </para>

    <programlisting>
GET /transfermoney?to=attacker&amp;amount=1000 HTTP/1.1
Host: victimbank.com
Cookie: ...
    </programlisting>
    <para>
      Even though browser believes it is asking for a resource, web application will perform action specified in the request from  the client - in this case, send money to the attacker. Such web application is vulnerable to Cross Site Request Forgery.
    </para>

    <important>
      <para>
        Web application should not change state or perform security sensitive actions upon receiving HTTP GET requests. Such behaviour is not compliant with HTTP and may create problems with caches, browser prefetching etc. 
      </para>
      <para>
      </para>
      <para>
        It is not enough to make sure that web application does not use HTTP GET requests to perform security sensitive actions - it is important that such requests are forbidden by the application. For example, Rails application's action can be invoked only with non-GET requests throughout the application, but still be routable through GET requests. 
      </para>
    </important>

    <para>
      Restricting security-sensitive operations to non-GET requests does not protect from CSRF attack itself. Even though common HTTP tags like <constant>&lt;img&gt;</constant>, <constant>&lt;script&gt;</constant> and others can be used to issue HTTP GET requests, there are other means to issue arbitrary requests against vulnerable application. 
    </para>
    <para>
      As example consider the code below:
    </para>
    <programlisting>
&lt;body onload="document.getElementById('f').submit()"&gt;
  &lt;form id="f" action="http://victimbank.com/transfermoney" method="post" name="form1"&gt;
    &lt;input name="to" value="attacker"&gt;
    &lt;input name="amount" value="1000"&gt;
  &lt;/form&gt;
&lt;/body&gt;
    </programlisting>

    <para>
      If user visits page containing a code similar to this one, upon loading the page browser will send a HTTP POST request with the parameters supplied by the attacker.
    </para>
    <para>
      There are several mechanisms available, that allow web application to identify requests issued by a third-party web page from the client's browser.
    </para>
    <section>
      <title>Synchronizer token pattern</title>
      <para>
        OWASP recommended method of CSRF protection is to include a challenge token in each sensitive request. The token must be unpredictable to the attacker, otherwise the attacker could guess it and include with his forged request. The token must also be tied to user's session - if the token is shared by users, they would be able to forge requests on behalf of others. It goes without saying that it cannot be part of the authentication tokens, since they are sent with each request automatically, which defeats the purpose of CSRF protection. However, this token needs to be generated only once per each session.
      </para>
      <para>
        The CSRF challenge token should be included in all non-GET requests, including Ajax requests. On the server side, application has to verify the token is included in request and is valid, and reset session otherwise.
      </para>

      <para>
        Synchronizer token pattern is also default CSRF protection mechanism for Rails applications. To enable CSRF protection, one has to enable it in application controller with

        <programlisting>
protect_from_forgery
        </programlisting>

        which will automatically include CSRF token in all non-get and XHR requests. The token itself is sent by the server in  meta tag of the web page like this:
        <programlisting>
&lt;meta content="authenticity_token" name="csrf-param" /&gt;
&lt;meta content="VBlgpnibfsxm1QykEmlOCbxqLRxx7kDGr57tjE+LLZk=" name="csrf-token" /&gt;
        </programlisting>
      </para>
      <para>
        If the request is not verified to be CSRF-free, Rails resets the session by default:
        <programlisting language="Ruby">
def handle_unverified_request
  reset_session
end
        </programlisting>
        If this does not effectively log out user due to application-specific behaviour, developers should redefine <constant>handle_unverified_token</constant>.
      </para>
      <para>
        The disadvantage of synchronizer token pattern is the need to rememnber the challenge token for each session on the server side.
      </para>
    </section>
    <section>
      <title>Double submit cookie pattern</title>
      <para>
        This method mitigates the problem of keeping state on the server side. Each sensitive request shall include a random value twice: in cookie, and as a request parameter. After receiving request, server verified that both values are equal, so this mechanism is stateless. 
      </para>
      <para>
        Assuming the random value meets the requirements on CSRF token, attacker cannot forge the CSRF requests. To do that, he would need an access to random value stored in a cookie of another site, which is prevented by Same Origin Policy. 
      </para>
      <para>
        This mechanism is arguably less secure than synchronizer token pattern. While it is hard for the attacker to read the random value from cookie, it is easier to write a value, for example by writing an attacker-specified value from a subdomain. 
      </para>
    </section>
    <section>
      <title>Encrypted token pattern</title>
      <para>
        Another stateless approach leverages encryption. The token sent by the server is triple User ID, Timestamp and Nonce, encrypted with server-side secret key. The token sent to the client in a hidden field, and returned by the client in a custom header field for Ajax requests or as a parameter for form-based requests. 
      </para>
      <para>
        Validation of token does not require any state on the server side aside from secret key. Upon receiving request, server decrypts the token and verifies User ID against session's User ID (if there is one) and Timestamp to prevent replay attacks. If decryption of the token yields malformed data or any of the checks fails, server blocks the potential attack.
      </para>
    </section>
    <section>
      <title>Checking referer header</title>
      <para></para>
    </section>
    <section>
      <title>Challenge-response</title>
      <para></para>
    </section>

    <section>
      <title>References</title>
      <itemizedlist>

        <listitem>
          <para>OWASP - Cross Site Request Forgery: <ulink url="https://www.owasp.org/index.php/Cross-Site_Request_Forgery_%28CSRF%29">https://www.owasp.org/index.php/Cross-Site_Request_Forgery_%28CSRF%29</ulink></para>
        </listitem>
        <listitem>
          <para>OWASP - CSRF Prevention cheat sheet: <ulink url="https://www.owasp.org/index.php/Cross-Site_Request_Forgery_%28CSRF%29_Prevention_Cheat_Sheet">https://www.owasp.org/index.php/Cross-Site_Request_Forgery_%28CSRF%29_Prevention_Cheat_Sheet</ulink></para>
        </listitem>
        <listitem>
          <para>CWE-352: Cross-Site Request Forgery (CSRF) <ulink url="https://cwe.mitre.org/data/definitions/352.html">https://cwe.mitre.org/data/definitions/352.html</ulink></para>
        </listitem>
        <listitem>
          <para>Encrypted Token pattern: <ulink url="http://insidethecpu.wordpress.com/2013/09/23/encrypted-token-pattern/">http://insidethecpu.wordpress.com/2013/09/23/encrypted-token-pattern/</ulink></para>
        </listitem>
      </itemizedlist>
    </section>
  </section>

  <section>
    <title>Command injection</title>
    <para>
      One of the most widespread types of attack is command injection attack, where data from untrusted source are being used by application to construct a command. The command is executed in the context of application and when the untrusted data is not sanitized properly, attacker might use this weakness to execute arbitrary command, potentially with elevated privileges.
    </para>

    <section>
      <title>SQL injection</title>
      <para>
        SQL injection is the most common type of command injection, where application constructs a SQL query from user supplied data. If not properly escaped, malicious attacker might be able to execute any SQL command on application's database, that can lead to information disclosure, unauthorized modification of data, execution of administrative operations or destruction of data.
      </para>

      <para>
        Ruby on Rails provides a good protection against SQL injection attacks by escaping several special SQL characters by default. However, this is far from making Rails applications safe against SQL injection. Consider a query against database:
        <programlisting language="Ruby">
User.where("name = '#{params[:name]}'")
        </programlisting>

        This would be translated to following SQL query:

        <programlisting>
SELECT "users".* FROM "users" WHERE (name = 'username')
        </programlisting>

        Such statement is vulnerable to SQL injection, since part of the SQL statement is passed as string in argument and Rails does not perform any escaping. Malicious string can match apostrophe and bracket in the statement, the follow with semicolon as statement separator and arbitrary SQL query. At the end double hyphens are necessary to comment out superfluous apostrophe:
        <programlisting>
>> params[:name] = "'); &lt;arbitrary statement&gt; --"
        </programlisting>

        Using Rails console we can see this how such input is translated to a SQL query:

        <programlisting language="Ruby">
>> params[:name] = "noname'); SELECT name, password_digest FROM users where userid = 'admin' --"
=> "noname'); SELECT name, password_digest FROM users where userid = 'admin' --"

>> User.where("name = '#{params[:name]}'")
  User Load (2.4ms)  SELECT "users".* FROM "users" WHERE (name = 'noname'); SELECT name, password_digest FROM users where userid = 'admin' --')
=> [#&lt;User name: "Administrator", password_digest: "$2a$10$m7XI628GGkdTH1JmkdMfluJyA360V1.QBtSbFMrc5Jwm..."&gt;]
        </programlisting>
      </para>
      <section>
        <title>(Un)safe Active Record queries</title>
        <para>
          Safer approach is to pass either array or hash as an argument and use Rails escaping mechanism to protect against SQL, as in
          <programlisting language="Ruby">
User.where("name = ?", params[:name])
          </programlisting>
          or 
          <programlisting language="Ruby">
User.where(name: params[:name])
          </programlisting>
        </para>
        <para>
          Alternatively, ActiveRecord also provides <command>ActiveRecord::sanitize</command> method which can be used to sanitize a string explicitly. 
        </para>
        <para>
          However, other ActiveRecord methods may be vulnerable to surprising SQL injection attacks, too. Consider <command>exists?</command> - when given string as an argument, it tries to convert it to integer, returning 0 when the conversion is impossible:
          <programlisting language="Ruby">
>> User.exists?("1")
  User Exists (0.9ms)  SELECT 1 AS one FROM "users" WHERE "users"."id" = 1 LIMIT 1
=> true

>> User.exists?("abc")
  User Exists (0.8ms)  SELECT 1 AS one FROM "users" WHERE "users"."id" = 0 LIMIT 1
=> false
          </programlisting>
        </para>
        <para>
          This might look like a safe behaviour and imply the following query is safe from SQL injection attack:
          <programlisting language="Ruby">
User.exists?(params[:id])
          </programlisting>
        </para>
        <para>
          The <command>exists?</command> method also accepts  array as an argument - in which case first element of array is used directly in SQL query without escaping:
          <programlisting language="Ruby">
>> params[:id] = ["id = '1'"]
=> ["id = '1'"]

>> User.exists?(params[:id])
  User Exists (0.8ms)  SELECT 1 AS one FROM "users" WHERE (id = '1') LIMIT 1
=> true
          </programlisting>
        </para>
        <para>
          This makes SQL injection attack possible:
          <programlisting language="Ruby">
>> params[:id] = ["1=1);UPDATE users SET password_digest='my_digest' WHERE userid='admin' --"]
=> ["1=1);UPDATE users SET password_digest='my_digest' WHERE userid='admin' --"]

>> User.exists?(params[:id])
  User Exists (67.6ms)  SELECT 1 AS one FROM "users" WHERE (1=1);UPDATE users SET password_digest='my_digest' WHERE userid='admin' --) LIMIT 1
=> false

>> User.where(userid: 'admin').first.password_digest
  User Load (1.0ms)  SELECT "users".* FROM "users" WHERE "users"."userid" = 'admin' LIMIT 1
  User Inst (0.4ms - 1rows)
=> "my_digest"
          </programlisting>
        </para>
        <para>
          The last obstacle is passing the user supplied parameter as an Array. Usually, all values of parameters are passed by Rack as strings, but it is also possible to explicitly specify that value of parameter is supposed to be Array in the HTTP request. If the parameter looks like 
          <programlisting>
key[]=value
          </programlisting>
        </para>
        <para>
          Rack assumes it should be an Array and performs conversion before the parameter is passed to Rails application. HTTP request that exploits <command>exists?</command> method called on <constant>params[:id]</constant> then looks like this:
          <programlisting>
GET /controller/action?id[]=1 = 1);UPDATE users SET password_digest='my_digest' WHERE userid='admin' --
          </programlisting>
        </para>
      </section>
    </section>

    <section>
      <title>OS command injection</title>
      <para>
        Another common vulnerability is invoking underlying OS commands with user supplied input without proper sanitization. Ruby provides several commands that can be used and if user's input is used as parameter to a system command without sanitization, he might be able to misuse it to execute arbitrary command.
      </para>
      <para>
        For example, when application contains call like
        <programlisting language="Ruby">
system "echo Hello #{params[:name]}!"
        </programlisting>

        user can use semicolon to terminate <command>echo</command> command and invoke command of his choice:
        <programlisting language="Ruby">
>> params[:name] = 'Joe;rm -rf /'
=> "Joe;touch /tmp/abc"
>> system "echo Hello #{params[:name]}"
Hello Joe
=> true        # and rm gets executed
        </programlisting> 
      </para>
      <para>
        <command>system</command> command can be used to explicitly separate OS command to invoke from the arguments passed to it:
        <programlisting language="Ruby">
system(command, *parameters)
        </programlisting>
      </para>
      <important>
        <para>
          Whenever system command is executed with arguments from untrusted source, extra care must be taken to prevent arbitrary code execution.
        </para>
      </important>
      <para>
        Also see <xref linkend="dangerous_methods"/>.
      </para>
    </section>

    <section>
      <title>References</title>
      <itemizedlist>
        <listitem>
          <para>Ruby on Rails Security Guide - SQL injection: <ulink url="http://guides.rubyonrails.org/security.html#sql-injection">http://guides.rubyonrails.org/security.html#sql-injection</ulink></para>
        </listitem>
        <listitem>
          <para>Rails SQL Injection: <ulink url="http://rails-sqli.org/">http://rails-sqli.org/</ulink></para>
        </listitem>
        <listitem>
          <para>OWASP SQL Injection: <ulink url="https://owasp.org/index.php/SQL_Injection">https://owasp.org/index.php/SQL_Injection</ulink></para>
        </listitem>
        <listitem>
          <para>CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'): <ulink url="http://cwe.mitre.org/data/definitions/89.html">http://cwe.mitre.org/data/definitions/89.html</ulink></para>
        </listitem>
        <listitem>
          <para>CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'): <ulink url="http://cwe.mitre.org/data/definitions/77.html">http://cwe.mitre.org/data/definitions/77.html</ulink></para>
        </listitem>

      </itemizedlist>
    </section>
  </section>


  <section>
    <title>Cross site tracing (XST)</title>
    <para></para>
  </section>

  <section>
    <title>Guidelines and principles</title>
    <para></para>
  </section>
</section>