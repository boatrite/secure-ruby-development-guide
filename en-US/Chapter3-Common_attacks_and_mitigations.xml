<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
<!ENTITY % BOOK_ENTITIES SYSTEM "Secure_Ruby_Development_Guide.ent">
%BOOK_ENTITIES;
]>
<section>
  <title>Common attacks and mitigations</title>
  <section>
    <title>Cross site scripting (XSS)</title>
    <para></para>
  </section>

  <section>
    <title>Cross site request forgery (CSRF)</title>
    <para>
      By default, browsers include user's authentication tokens (such as cookies, HTTP basic authentication credentials etc.) with every request to the web application. This allows client to authenticate once and each following request to the web application will be authenticated without prompting the user for credentials. However, this gives client's browser ability to make authenticated requests on behalf of the user without user's explicit consent.
    </para>

    <para>
      This behaviour can be misused by the attacker to confuse client's browser into issuing an authenticated request. For example, if attacker's website contains this simple script tag
    </para>

    <programlisting>
&lt;script src="http://victimbank.com/transfermoney?to=attacker&amp;amount=1000"/&gt;
    </programlisting>

    <para>
      browser will issue a HTTP GET request to victimbank.com with parameters supplied by the attacker. The browser does not know anything about the resource that is being requested by the attacker's site - whether it is malicious of harmless - and it requests the script from the specified URL. If the user is authenticated at that moment, browser will also include his credentials, so the request would look like this:
    </para>

    <programlisting>
GET /transfermoney?to=attacker&amp;amount=1000 HTTP/1.1
Host: victimbank.com
Cookie: ...
    </programlisting>
    <para>
      Even though browser believes it is asking for a resource, web application will perform action specified in the request from  the client - in this case, send money to the attacker. Such web application is vulnerable to Cross Site Request Forgery.
    </para>

    <important>
      <para>
        Web application should not change state or perform security sensitive actions upon receiving HTTP GET requests. Such behaviour is not compliant with HTTP and may create problems with caches, browser prefetching etc. 
      </para>
      <para>
      </para>
      <para>
        It is not enough to make sure that web application does not use HTTP GET requests to perform security sensitive actions - it is important that such requests are forbidden by the application. For example, Rails application's action can be invoked only with non-GET requests throughout the application, but still be routable through GET requests. 
      </para>
    </important>

    <para>
      Restricting security-sensitive operations to non-GET requests does not protect from CSRF attack itself. Even though common HTTP tags like <constant>&lt;img&gt;</constant>, <constant>&lt;script&gt;</constant> and others can be used to issue HTTP GET requests, there are other means to issue arbitrary requests against vulnerable application. 
    </para>
    <para>
      As example consider the code below:
    </para>
    <programlisting>
&lt;body onload="document.getElementById('f').submit()"&gt;
  &lt;form id="f" action="http://victimbank.com/transfermoney" method="post" name="form1"&gt;
    &lt;input name="to" value="attacker"&gt;
    &lt;input name="amount" value="1000"&gt;
  &lt;/form&gt;
&lt;/body&gt;
    </programlisting>

    <para>
      If user visits page containing a code similar to this one, upon loading the page browser will send a HTTP POST request with the parameters supplied by the attacker. 
    </para>
    <para>
      There are several mechanisms available, that allow web application to identify requests issued by a third-party web page from the client's browser.
    </para>
    <section>
      <title>Synchronizer token pattern</title>
      <para></para>
    </section>
    <section>
      <title>Double submit cookie pattern</title>
      <para></para>
    </section>
    <section>
      <title>Encrypted token pattern</title>
      <para></para>
    </section>
    <section>
      <title>Checking referer header</title>
      <para></para>
    </section>
    <section>
      <title>Challenge-response</title>
      <para></para>
    </section>

    <section>
      <title>References</title>
      <itemizedlist>

        <listitem>
          <para>OWASP - Cross Site Request Forgery: <ulink url="https://www.owasp.org/index.php/Cross-Site_Request_Forgery_%28CSRF%29">https://www.owasp.org/index.php/Cross-Site_Request_Forgery_%28CSRF%29</ulink></para>
        </listitem>
        <listitem>
          <para>OWASP - CSRF Prevention cheat sheet: <ulink url="https://www.owasp.org/index.php/Cross-Site_Request_Forgery_%28CSRF%29_Prevention_Cheat_Sheet">https://www.owasp.org/index.php/Cross-Site_Request_Forgery_%28CSRF%29_Prevention_Cheat_Sheet</ulink></para>
        </listitem>
        <listitem>
          <para>CWE-352: Cross-Site Request Forgery (CSRF) <ulink url="https://cwe.mitre.org/data/definitions/352.html">https://cwe.mitre.org/data/definitions/352.html</ulink></para>
        </listitem>
      </itemizedlist>
    </section>
  </section>

  <section>
    <title>Command injection</title>
    <para>
      One of the most widespread types of attack is command injection attack, where data from untrusted source are being used by application to construct a command. The command is executed in the context of application and when the untrusted data is not sanitized properly, attacker might use this weakness to execute arbitrary command, potentially with elevated privileges.
    </para>

    <section>
      <title>SQL injection</title>
      <para>
        SQL injection is the most common type of command injection, where application constructs a SQL query from user supplied data. If not properly escaped, malicious attacker might be able to execute any SQL command on application's database, that can lead to information disclosure, unauthorized modification of data, execution of administrative operations or destruction of data.
      </para>

      <para>
        Ruby on Rails provides a good protection against SQL injection attacks by escaping several special SQL characters by default. However, this is far from making Rails applications safe against SQL injection. Consider a query against database:
        <programlisting language="Ruby">
User.where("name = '#{params[:name]}'")
        </programlisting>

        This would be translated to following SQL query:

        <programlisting>
SELECT "users".* FROM "users" WHERE (name = 'username')
        </programlisting>

        Such statement is vulnerable to SQL injection, since part of the SQL statement is passed as string in argument and Rails does not perform any escaping. Malicious string can match apostrophe and bracket in the statement, the follow with semicolon as statement separator and arbitrary SQL query. At the end double hyphens are necessary to comment out superfluous apostrophe:
        <programlisting>
>> params[:name] = "'); &lt;arbitrary statement&gt; --"
        </programlisting>

        Using Rails console we can see this how such input is translated to a SQL query:

        <programlisting language="Ruby">
>> params[:name] = "noname'); SELECT name, password_digest FROM users where userid = 'admin' --"
=> "noname'); SELECT name, password_digest FROM users where userid = 'admin' --"

>> User.where("name = '#{params[:name]}'")
  User Load (2.4ms)  SELECT "users".* FROM "users" WHERE (name = 'noname'); SELECT name, password_digest FROM users where userid = 'admin' --')
=> [#&lt;User name: "Administrator", password_digest: "$2a$10$m7XI628GGkdTH1JmkdMfluJyA360V1.QBtSbFMrc5Jwm..."&gt;]
        </programlisting>
      </para>
      <section>
        <title>(Un)safe Active Record queries</title>
        <para>
          Safer approach is to pass either array or hash as an argument and use Rails escaping mechanism to protect against SQL, as in
          <programlisting language="Ruby">
User.where("name = ?", params[:name])
          </programlisting>
          or 
          <programlisting language="Ruby">
User.where(name: params[:name])
          </programlisting>
        </para>
        <para>
          Alternatively, ActiveRecord also provides <command>ActiveRecord::sanitize</command> method which can be used to sanitize a string explicitly. 
        </para>
        <para>
          However, other ActiveRecord methods may be vulnerable to surprising SQL injection attacks, too. Consider <command>exists?</command> - when given string as an argument, it tries to convert it to integer, returning 0 when the conversion is impossible:
          <programlisting language="Ruby">
>> User.exists?("1")
  User Exists (0.9ms)  SELECT 1 AS one FROM "users" WHERE "users"."id" = 1 LIMIT 1
=> true

>> User.exists?("abc")
  User Exists (0.8ms)  SELECT 1 AS one FROM "users" WHERE "users"."id" = 0 LIMIT 1
=> false
          </programlisting>
        </para>
        <para>
          This might look like a safe behaviour and imply the following query is safe from SQL injection attack:
          <programlisting language="Ruby">
User.exists?(params[:id])
          </programlisting>
        </para>
        <para>
          The <command>exists?</command> method also accepts  array as an argument - in which case first element of array is used directly in SQL query without escaping:
          <programlisting language="Ruby">
>> params[:id] = ["id = '1'"]
=> ["id = '1'"]

>> User.exists?(params[:id])
  User Exists (0.8ms)  SELECT 1 AS one FROM "users" WHERE (id = '1') LIMIT 1
=> true
          </programlisting>
        </para>
        <para>
          This makes SQL injection attack possible:
          <programlisting language="Ruby">
>> params[:id] = ["1=1);UPDATE users SET password_digest='my_digest' WHERE userid='admin' --"]
=> ["1=1);UPDATE users SET password_digest='my_digest' WHERE userid='admin' --"]

>> User.exists?(params[:id])
  User Exists (67.6ms)  SELECT 1 AS one FROM "users" WHERE (1=1);UPDATE users SET password_digest='my_digest' WHERE userid='admin' --) LIMIT 1
=> false

>> User.where(userid: 'admin').first.password_digest
  User Load (1.0ms)  SELECT "users".* FROM "users" WHERE "users"."userid" = 'admin' LIMIT 1
  User Inst (0.4ms - 1rows)
=> "my_digest"
          </programlisting>
        </para>
        <para>
          The last obstacle is passing the user supplied parameter as an Array. Usually, all values of parameters are passed by Rack as strings, but it is also possible to explicitly specify that value of parameter is supposed to be Array in the HTTP request. If the parameter looks like 
          <programlisting>
key[]=value
          </programlisting>
        </para>
        <para>
          Rack assumes it should be an Array and performs conversion before the parameter is passed to Rails application. HTTP request that exploits <command>exists?</command> method called on <constant>params[:id]</constant> then looks like this:
          <programlisting>
GET /controller/action?id[]=1 = 1);UPDATE users SET password_digest='my_digest' WHERE userid='admin' --
          </programlisting>
        </para>
      </section>
    </section>

    <section>
      <title>OS command injection</title>
      <para>
        Another common vulnerability is invoking underlying OS commands with user supplied input without proper sanitization. Ruby provides several commands that can be used and if user's input is used as parameter to a system command without sanitization, he might be able to misuse it to execute arbitrary command.
      </para>
      <para>
        For example, when application contains call like
        <programlisting language="Ruby">
system "echo Hello #{params[:name]}!"
        </programlisting>

        user can use semicolon to terminate <command>echo</command> command and invoke command of his choice:
        <programlisting language="Ruby">
>> params[:name] = 'Joe;rm -rf /'
=> "Joe;touch /tmp/abc"
>> system "echo Hello #{params[:name]}"
Hello Joe
=> true        # and rm gets executed
        </programlisting> 
      </para>
      <para>
        <command>system</command> command can be used to explicitly separate OS command to invoke from the arguments passed to it:
        <programlisting language="Ruby">
system(command, *parameters)
        </programlisting>
      </para>
      <important>
        <para>
          Whenever system command is executed with arguments from untrusted source, extra care must be taken to prevent arbitrary code execution.
        </para>
      </important>
      <para>
        Also see <xref linkend="dangerous_methods"/>.
      </para>
    </section>

    <section>
      <title>References</title>
      <itemizedlist>
        <listitem>
          <para>Ruby on Rails Security Guide - SQL injection: <ulink url="http://guides.rubyonrails.org/security.html#sql-injection">http://guides.rubyonrails.org/security.html#sql-injection</ulink></para>
        </listitem>
        <listitem>
          <para>Rails SQL Injection: <ulink url="http://rails-sqli.org/">http://rails-sqli.org/</ulink></para>
        </listitem>
        <listitem>
          <para>OWASP SQL Injection: <ulink url="https://owasp.org/index.php/SQL_Injection">https://owasp.org/index.php/SQL_Injection</ulink></para>
        </listitem>
        <listitem>
          <para>CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'): <ulink url="http://cwe.mitre.org/data/definitions/89.html">http://cwe.mitre.org/data/definitions/89.html</ulink></para>
        </listitem>
        <listitem>
          <para>CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'): <ulink url="http://cwe.mitre.org/data/definitions/77.html">http://cwe.mitre.org/data/definitions/77.html</ulink></para>
        </listitem>

      </itemizedlist>
    </section>
  </section>


  <section>
    <title>Cross site tracing (XST)</title>
    <para></para>
  </section>

  <section>
    <title>Guidelines and principles</title>
    <para></para>
  </section>
</section>