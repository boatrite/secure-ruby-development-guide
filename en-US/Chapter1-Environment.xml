<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
<!ENTITY % BOOK_ENTITIES SYSTEM "Secure_Ruby_Development_Guide.ent">
%BOOK_ENTITIES;
]>
<chapter id="chap-Secure_Ruby_Development_Guide-Environment">
	<title>Environment</title>
	<para>
		Development environment can significantly affect quality and security of code
and investing certain effort into proper setup can result in saved development
time, better code coverage, more readable and secure code etc. In general,
automated checks provide a good baseline and are less prone to unintentional 
mistakes than developers.
	</para>
	<section id="sect-Secure_Ruby_Development_Guide-Environment-Code_Quality_Metrics">
		<title>Code quality metrics</title>
		<para>
			Security is just one aspect of code quality along with reliability, correctness
and others. These metrics overlap a lot, for example denial of service can be
seen as both security and reliability issue. Therefore improvement in any of
these areas is likely to affect others.
		</para>
		<para>
			Increasing code quality by reducing complexity, duplication of code and
mainaining good readability is a good first step towards security. All other things 
being equal, more complex code will have more weaknesses than simpler one.
		</para>
		<para>
			Several gems can help with improving code quality:
		</para>
		<itemizedlist>
			<listitem>
        <para>
        	<ulink url="https://github.com/railsbp/rails_best_practices">Rails Best Practices</ulink>
        	is a popular gem among rails developers and new checks are implemented based on voting of community.
      	</para>
      </listitem>
      <listitem>
        <para>
        	<ulink url="https://github.com/bbatsov/rubocop">rubocop</ulink>
        	is a style checker and implements vast amount of checks based on 
  				<ulink url="https://github.com/bbatsov/ruby-style-guide">Ruby Style Guide</ulink>
        </para>
      </listitem>
      <listitem>
      	<para>
      		<ulink url="https://github.com/metricfu/metric_fu">metric_fu</ulink>
      		combines several popular code metric tools like <ulink url="https://github.com/troessner/reek">Reek</ulink>, <ulink url="https://github.com/seattlerb/flog">Flog</ulink>, <ulink url="https://github.com/seattlerb/flay">Flay</ulink>, <ulink url="https://github.com/square/cane">Cane</ulink> etc.
      	</para>
      </listitem>
		</itemizedlist>

		<para>
			These are just few examples and actual setup may vary from project to project.
			However, they help developers keep code complexity low in an automated fashion
			and can be easily integrated into workflow. 
		</para>
	</section>
	
	<section id="sect-Secure_Ruby_Development_Guide-Environment-Dependency_management">
		<title>Dependency management</title>
		<para>
			Dependencies in form of gems can be another source of vulnerabilities in Ruby applications.
		</para>

    <section id="sect-Secure_Ruby_Development_Guide-Environment-Outdated_Dependencies">
      <title>Outdated Dependencies</title>
      <para>
        <ulink url="http://bundler.io/">Bundler</ulink> is the de facto standard for managing Ruby application dependencies. Developer can specify required dependencies and their versions in Gemfile and bundler automatically resolves dependencies and prepares environment for application to run in. Bundler freezes exact versions of dependencies in Gemfile.lock and everytime this file is present, depencency resolution step is skipped and exact versions of gems from Gemfile.lock are installed.
      </para>
      <para>
        Freezing versions of dependencies has a security impact. If a dependency is vulnerable and new version contains the fix, Gemfile.lock has to be updated. Detection of outdated versions of dependencies is something that can be automated and several gems help with this using information provided by <ulink url="https://github.com/rubysec/ruby-advisory-db/">rubysec-db</ulink>.
      </para>
      <para>
        <ulink url="http://www.rubysec.com">Rubysec</ulink> project maintains rubysec-db database of all security advisories related to Ruby libraries. This database covers most of the popular gems and provides data to identify vulnerable and patched versions of dependencies.
      </para>
      <para>
        <ulink url="https://github.com/rubysec/bundler-audit">bundler-audit</ulink> is a gem maintainted by rubysec project that automatically scans Gemfile.lock and reports any unpatched dependencies or insecure sources.
      </para>
      <para>
        <ulink url="https://github.com/appfolio/gemsurance">gemsurance</ulink> also works on top of rubysec-db. Unlike bundler-audit it outputs html report and lists outdated gems as well. Another useful feature is possibility to integrate the check with RSpec and make your tests fail whenever vulnerable dependency is detected.
      </para>
      <important>
        <para>
          It is highly recommended to set up automated checks for outdated dependencies.
        </para>
      </important>
    </section>
    <section>
      <title>Vendoring dependencies</title>
      <para>
        Another way of freezing dependencies is checking their source code into vendor folder in application. With bundler this practice becomes obsolete. Another, still valid, usecase is when dependency needs to be slightly modified to suit needs of application.
      </para>
      <para>
        By checking the dependency into the application`s repository, developer takes responsibility of tracking bugs and vulnerabilities and updating vendored gems. However, backporting commits that fix security issues from upstream version will render automatic tools for checking dependencies useless, as they will rely on gem versions, which will not correspond with the vendored code.
      </para>
    </section>
    <section>
      <title>Gem signing</title>
      <para>
        Gem signing is already implemented in rubygems and is based on x509 certificates, even though discussion about future implementation is <ulink url="https://github.com/rubygems-trust/rubygems.org/wiki">ongoing</ulink>. There is no PKI, so user who wants to verify gem`s integrity must explicitly download and trust certificate that was used to sign the gem. Establishing trust in certificate of party user has no prior relationship with over internet can be diffucult and unscalable (certificate chains and signing can alleviate this, see below).

        <important>
          <para>
            Assuming user verified the certificate  belongs to the developer it says, signature protects integrity of gem as it is distributed and gives user a mechanism to detect modifications of gem after it was signed.
          </para>
          <para>
            However, signatures do not guarantee trustworthiness of gem author.
          </para>
        </important>
      </para>
      <para>
        Developer can generate his private key and self signed certificate with:
        <programlisting>
$ gem cert --build &lt;email address&gt;
...
$ chmod 600 gem-private_key.pem gem-public_cert.pem
        </programlisting>
      </para>
      <para>
        This command will generate self-signed 2048 bit RSA with SHA1 certificate (this  configuration is currently hardcoded) stored in PEM format. 
      </para>
      <important>
        <para>
          Generated private key will not be passphrase protected, and it has to be encrypted manually:
<programlisting language="Bash">
$ openssl rsa -des3 -in &lt;private key&gt; -out &lt;encrypted private key&gt;
</programlisting>
        </para>
      </important>
      <para>
        To sign the gem, following needs to be added to gemspec:
        <programlisting language="Ruby">
s.cert_chain = &lt;path to public certificate&gt;
s.signing_key = &lt;path to private key&gt; if $0 =~ /gem\z/
        </programlisting>
      </para>
      <para>
        After building the gem, one can verify it has been signed with:
        <programlisting>
$ gem spec testgem-1.0.0.gem cert_chain
...
$ tar tf testgem-1.0.0.gem
data.tar.gz
metadata.gz
data.tar.gz.sig
metadata.gz.sig
        </programlisting>
      </para>

      <section>
        <title>Installation and policies</title>
        <para>
          To make use of signatures in gems, user has to specify security policy during gem installation (it is turned off by default):

          <programlisting>
$ gem install -P HighSecurity testgem
          </programlisting>
        </para>
        <para>
          There are 4 available security policies:
          <variablelist>
            <varlistentry>
              <term>No policy</term>
              <listitem>
                <para>Signed packages are treated as unsigned.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>LowSecurity</term>
              <listitem>
                <para>Still pretty much no security. Rubygems will make sure signature matches certificate and certificate hasn`t expired.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>MediumSecurity</term>
              <listitem>
                <para>For signed gems, signature is verified against certificate, certificate validity is checked and certificate chain is checked too. Packages from untrusted sources won`t be installed (user has to explicitly trust the cerficate, see below). Unsigned gems are installed normally.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>HighSecurity</term>
              <listitem>
                <para>Same as medium, but unsigned gems are not installed.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <warning>
          <para>Since signatures protect integrity of gem as it`s being distributed from developer to users, the only policy with security impact is <constant>HighSecurity</constant>. With <constant>MediumSecurity</constant>, attacker can always intercept gem, strip signatures, modify it and serve users that accept unsigned gems.</para>
        </warning>
        </para>
        <para>
          To install signed gem under medium or high security policy, user has to download certificate from external source, verify it`s authenticity and explicitly add it to his local database of trusted certificates:
          <programlisting>
$ gem cert --add &lt;certificate&gt;
          </programlisting>
        </para>
        <para>
          This command will store public certificate to <filename>~/.gem/trust</filename> directory. Name of the certificate will contain hexdigest of the subject of certificate, so if users adds another certificate with the same subject as one of the already trusted ones, original one will be overwritten without notice.
        </para>
        <para>
          To avoid overwriting existing certificate, make sure subject of certificate being added is different from certificates that are already trusted:
          <programlisting>
$ openssl x509 -text -in &lt;certificate&gt; | grep Subject:
    Subject: CN=test, DC=example, DC=com
$ gem cert --list
...
          </programlisting>
        </para>
        <para>
          Bundler supports gem signing and trust policies since version 1.3 and user can specify security policy during installation:
          <programlisting>
$ bundle install --trust-policy=HighSecurity
          </programlisting>

          <warning>
            <para>Gems that are installed by bundler from repository like
              <programlisting>
gem 'jquery-datatables-rails', git: 'git://github.com/rweng/jquery-datatables-rails.git'
              </programlisting>
              bypass security policy, as they are not installed using <command>gem</command> command, but cloned into bundler folder.</para>
          </warning>
        </para>
        <para>
          A small gem <command>bundler_signature_check</command> can be used to check <filename>Gemfile</filename> and determine which gems are signed, with suggestion which security policy can be currently safely used (note that <command>bundler_signature_check</command> is signed and it`s dependencies <command>bundler</command> and <command>rake</command> are likely already installed, so <constant>HighSecurity</constant> can be used):
          <programlisting>
$ gem install -P HighSecurity bundler_signature_check
$ bundler_signature_check
...
          </programlisting>
        </para> 
      </section>

      <section>
        <title>Certificate chains and signing</title>
        <para>

        </para>
      </section>
        
      <section>
        <title>References:</title>
        <para>
          <itemizedlist>
            <listitem>
              <para>
              Rubygems Security page <ulink url="http://guides.rubygems.org/security/">http://guides.rubygems.org/security/</ulink></para>
            </listitem>
            <listitem>
              <para>
              Documentation of <classname>Gem::Security</classname> module  <ulink url="http://rubygems.rubyforge.org/rubygems-update/Gem/Security.html">http://rubygems.rubyforge.org/rubygems-update/Gem/Security.html</ulink></para>
            </listitem>
            <listitem>
              <para>
              Ben Smith`s Hacking with gems presentation <ulink url="http://www.youtube.com/watch?v=z-5bO0Q1J9s">http://www.youtube.com/watch?v=z-5bO0Q1J9s</ulink></para>
            </listitem>
          </itemizedlist>
        </para>
      </section>
    </section>
	</section>

  <section>
    <title>Static code analysis with Brakeman</title>
    <para>
      <ulink url="http://brakemanscanner.org">Brakeman</ulink> is a static code scanner for Ruby on Rails applications. It does not require any configuration and can be run out-of-the-box on source of rails application. It performs static code analysis, so it does not require rails application to be set up, but rather parses the source code and looks for common vulnerable patterns.
    </para>
    <para>
      Brakeman gem is signed, but some of its dependencies are not, so to install run:
      <programlisting>
$ gem install -P MediumSecurity brakeman
      </programlisting>
    </para>
    <para>
      To execute scan on application, run brakeman from rails application repository:
      <programlisting>
$ brakeman -o report.html --path &lt;path to rails app&gt;
      </programlisting>
    </para>
    <para>
      The format of the output is determined by file extension or by <command>-f</command> flag. Currently supported formats are <constant>html</constant>,<constant>json</constant>,<constant>tabs</constant>, <constant>csv</constant> and <constant>text</constant>.
    </para>
    <para>
      Brakeman output contains warnings in format
      <programlisting>
+------------+-----------+---------+--------------------+------------------------------------------+
| Confidence | Class     | Method  | Warning Type       | Message                                  |
+------------+-----------+---------+--------------------+------------------------------------------+
| High       | Foo       | bar     | Denial of Service  | Symbol conversion from unsafe String ... |
      </programlisting>
    </para>
    <para>
      As static code scanner Brakeman does not analyze the behaviour of code when run 
      and lacks execution context (e.g. it does not know about dead code that`s never
      executed). Therefore Brakeman output usually contains also false warnings.
      There are 3 confidence levels to help developers determine possible false 
      warnings and prioritize when reviewing the output: <constant>High</constant>, 
      <constant>Medium</constant> and <constant>Weak</constant>.
    </para>
    <section>
      <title>Continuous integration</title>
      <para>
        Good way to use Brakeman is to integrate it into workflow of a project 
        and fix the reported problems before they are committed into repository.
      </para>
      <para>
        Creating a rake task is easy with
        <programlisting>
$ brakeman --rake
        </programlisting>
        which creates file <filename>lib/tasks/brakeman.rake</filename>
      </para>
      <para>
        Another useful options is to create a configuration file from a command
        line options:
        <programlisting>
$ brakeman -C &lt;config file&gt; &lt;options&gt;
        </programlisting>
        which can be later used:
        <programlisting>
$ brakeman -c &lt;config file&gt;
        </programlisting>
      </para>
      <para>
        Very useful feature is comparison with older scan result and outputting 
        only difference between reports - developers can then easily identify 
        warnings that were just added or fixed:
        <programlisting>
$ brakeman --compare &lt;old result in json&gt; -o &lt;output in json&gt;
        </programlisting>
        The output is always in json (<command>-f</command> is ignored).
      </para>
    </section>
    <section>
      <title>Reducing number of false warnings</title>
      <para>
        There are several ways to reduce number of false warnings, most of which 
        can be dangerous. Reducing number of false warnings might be meaningful
        when Brakeman is adopted by an existing project - in such cases initial
        report can be overwhelming and ignoring warnings that are likely to be false
        can be crucial. However, this shall be considered only temporary solution.
        <important>
          <para>
            Reduction of false warnings by skipping certain checks or ignoring
            certain files is dangerous. Even if all currently reported warnings 
            are false, future commits might introduce flaws that would otherwise
            be reported. This greatly reduces effectiveness of Brakeman and its 
            value for project.
          </para>
        </important>
      </para>

      <para>
        One way to reduce number of warnings is to set minimum confidence level:
        <programlisting>
$ brakeman -w &lt;level&gt;
        </programlisting>
        where level <constant>1</constant> indicates Weak confidence, level
         <constant>2</constant> Medium and <constant>3</constant> High confidence.
      </para>

      <para>
        Another option is to specify list of safe methods:
        <programlisting>
$ brakeman -s &lt;comma separated list of methods&gt;
        </programlisting>
      </para>
      <para>
        This will add methods to the set of known safe methods and certain checks
        will skip them without producing a warning. For example, Cross site scripting
        checker maintains a set of methods which produce safe output (it contains
        methods like <command>escapeHTML</command>) and safe methods specified 
        as command line argument are added to the list.
      </para>
      <para>
        You can skip processing <filename>lib</filename> directory and/or specify 
        files to be skipped:
        <programlisting>
$ brakeman --skip-libs
$ brakeman --skip-files &lt;comma separated list of files&gt;
        </programlisting>
      </para>
    </section>
    
  </section>
</chapter>

